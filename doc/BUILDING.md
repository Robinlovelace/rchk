# Getting Bitcode Files

Building R with CLANG normally is not a problem and it is also mentioned in
[R Installation and Administration]
(http://cran.r-project.org/doc/manuals/r-release/R-admin.html#Clang). 
During such build, one gets the executable R binary (`R.bin') and shared
libraries in executable format (e.g.  `stats.so`).  But, we need to have a
bitcode version of these files (`R.bin.bc` or`stats.so.bc`).

We need the C compiler (CLANG) to generate bitcode object files and
ultimately link them into the bitcode version of `R.bin.bc' or
`stats.so.bc'.  At the same time, we also need executable binaries, e.g. 
`R.bin', because the build process needs them - to compile packages, install
them, etc - not mentioning the test C files generated by
autotools/configure. So, we need the C compiler also to generate executable
binaries.

## Using a compiler wrapper script

The simple way is to run the C compiler twice for each source file, once
generating the object file in executable format and once in bitcode format. 
This leads indeed to long compile time, but it is easy to set up.  One can
use our modified version of the
[whole-program-llvm](https://github.com/kalibera/whole-program-llvm) wrapper
script by Tristan Ravitch.

```
export CFLAGS="-Wall -g -O0"
export CC=/opt/whole-program-llvm/wllvm
export CXX=/opt/whole-program-llvm/wllvm++
export PATH=/opt/clang+llvm-3.6.1-x86_64-linux-gnu/bin:$PATH
export LLVM_COMPILER=clang

export BITCODE_DIR=`pwd`/bitcode
#rm -rf $BITCODE_DIR

./configure --with-blas --with-lapack --enable-R-static-lib
make
```

As a result, one gets executable binaries (`R.bin', `stats.so') and bitcode
versions of the object files (in `bitcode` directory). The binaries have
encoded in their meta-data from which object files they have been linked. To
get actually the bitcode version of the binaries, this meta-data is read and
respective bitcode versions of the object files are linked (by `extract-bc`).

```
export PATH=/home/tomas/work/opt/clang+llvm-3.6.1-x86_64-linux-gnu/bin:$PATH
export BITCODE_DIR=`pwd`/bitcode

~/work/wllvm/whole-program-llvm/extract-bc src/main/R.bin
find . -name *.so -exec /opt/whole-program-llvm/extract-bc {} \;

```

The wrapper script works with the binary distribution of
[CLANG+LLVM](http://llvm.org/releases/download.html#3.6.1), so one does not
have to build LLVM on the supported platforms. The same binary distribution
of LLVM can be used to build `rchk'. On Fedora 20, we built LLVM this way:

```
wget http://llvm.org/releases/3.6.1/cfe-3.6.1.src.tar.xz
wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz
wget http://llvm.org/releases/3.6.1/compiler-rt-3.6.1.src.tar.xz

tar xf llvm-3.6.1.src.tar.xz
cd llvm-3.6.1.src/tools/
tar xf ../../cfe-3.6.1.src.tar.xz
mv cfe-3.6.1.src clang
tar xf ../../compiler-rt-3.6.1.src.tar.xz
mv compiler-rt-3.6.1.src compiler-rt

cd ../../
./configure --prefix=/var/scratch/tomas/opt/llvm/inst3.6.1 --enable-bindings=none
make
make install
```

## Using LTO and bitcode object files

The double-building of each source file is a waste of resources. 
Conceptually, it should be possible to only generate bitcode object files by
the C compiler and use them in the end to get both executable binaries and
bitcode files for the binaries. In principle this should work as LLVM
supports link-time optimizations (LTO) which already need the bitcode files
at link-time. But, in practice it is hard to get working. We've been doing
this with LLVM 3.4, but not with newer LLVM anymore, the former method of
the wrapper script is preferred now and more reliable. The problems with the
LTO method are:

1. System utilities like `ld`, `ranlib`, `ar`, `nm` cannot work with LLVM
bitcode given as input.

2. We need the linker to generate both bitcode and executable binary, as the
R build process always needs to run generated binaries.

### System utilities working with bitcode

For (1), one needs to use the [GNU Gold
Linker](http://en.wikipedia.org/wiki/Gold_%28linker%29) instead of the `BFD`
linker, one needs recent `binutils` that support `plugins`, and one needs
the `LLVM gold` plugin. Moreover, one then has to modify environment
variables that influence the R build so that the `LLVM gold plugin` is used
with `ld`, `ranlib`, `ar`, and `nm`. The LLVM gold plugin is not part of the
binary `CLANG+LLVM` distribution, so one needs to build LLVM from sources to
get it.

With Ubuntu 14.04, a usable version of LLVM (including the gold plugin),
CLANG, and binutils is available in the standard Ubuntu package system (see
packages `llvm`, `llvm-3.4`, `llvm-3.4-dev`, `llvm-3.4-runtime`).  One can
also switch the system to the `gold` linker (make `/usr/bin/ld` point to
`/usr/bin/ld.gold`).

With Fedora 20, we built `binutils` from source and then we built LLVM 3.4.2
against these binutils, getting also the LLVM gold plugin.  We have modified
the `PATH` variable to switch to the `gold` linker, we did not have to
switch the whole system to `gold` linker (so one does not need root access).

### Building R, generating bitcode files

For (2), one needs to use LTO (link-time-optimization) and tell the linker
to generate LLVM bitcode in addition to the executables.  With LLVM 3.4, one
can do this using `-Wl,-plugin-opt=also-emit-llvm` (passing option
`also-emit-llvm` to the `LLVM gold plugin`).  This option has been removed
as of `LLVM 3.6`. We were using bitcode files obtained with LLVM 3.4 for a
while with `rchk` built using LLVM 3.5, and it worked fine.

### More reading

[LLVM Gold Plugin](http://llvm.org/docs/GoldPlugin.html)
